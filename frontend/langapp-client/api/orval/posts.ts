/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * LangApp.Api
 * OpenAPI spec version: 1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  CreatePostCommentRequest,
  CreatePostRequest,
  EditPostCommentRequest,
  EditPostRequest,
  GetPostsByGroupParams,
  PostDto,
  PostSlimDtoPagedResult,
} from './langAppApi.schemas';

import { customAxiosMutator } from '../axiosMutator';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const getPost = (
  id: string,
  options?: SecondParameter<typeof customAxiosMutator>,
  signal?: AbortSignal
) => {
  return customAxiosMutator<PostDto>(
    { url: `/api/v1/posts/${id}`, method: 'GET', signal },
    options
  );
};

export const getGetPostQueryKey = (id: string) => {
  return [`/api/v1/posts/${id}`] as const;
};

export const getGetPostInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPost>>>,
  TError = void,
>(
  id: string,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPost>>, TError, TData>>;
    request?: SecondParameter<typeof customAxiosMutator>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPostQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPost>>> = ({ signal }) =>
    getPost(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPost>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetPostInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPost>>>;
export type GetPostInfiniteQueryError = void;

export function useGetPostInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPost>>>,
  TError = void,
>(
  id: string,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPost>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPost>>,
          TError,
          Awaited<ReturnType<typeof getPost>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPostInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPost>>>,
  TError = void,
>(
  id: string,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPost>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPost>>,
          TError,
          Awaited<ReturnType<typeof getPost>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPostInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPost>>>,
  TError = void,
>(
  id: string,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPost>>, TError, TData>>;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetPostInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPost>>>,
  TError = void,
>(
  id: string,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPost>>, TError, TData>>;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPostInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPostQueryOptions = <TData = Awaited<ReturnType<typeof getPost>>, TError = void>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPost>>, TError, TData>>;
    request?: SecondParameter<typeof customAxiosMutator>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPostQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPost>>> = ({ signal }) =>
    getPost(id, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!id, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPost>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPostQueryResult = NonNullable<Awaited<ReturnType<typeof getPost>>>;
export type GetPostQueryError = void;

export function useGetPost<TData = Awaited<ReturnType<typeof getPost>>, TError = void>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPost>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPost>>,
          TError,
          Awaited<ReturnType<typeof getPost>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPost<TData = Awaited<ReturnType<typeof getPost>>, TError = void>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPost>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPost>>,
          TError,
          Awaited<ReturnType<typeof getPost>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPost<TData = Awaited<ReturnType<typeof getPost>>, TError = void>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPost>>, TError, TData>>;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetPost<TData = Awaited<ReturnType<typeof getPost>>, TError = void>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPost>>, TError, TData>>;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPostQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const editPost = (
  id: string,
  editPostRequest: EditPostRequest,
  options?: SecondParameter<typeof customAxiosMutator>
) => {
  return customAxiosMutator<void>(
    {
      url: `/api/v1/posts/${id}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: editPostRequest,
    },
    options
  );
};

export const getEditPostMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof editPost>>,
    TError,
    { id: string; data: EditPostRequest },
    TContext
  >;
  request?: SecondParameter<typeof customAxiosMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof editPost>>,
  TError,
  { id: string; data: EditPostRequest },
  TContext
> => {
  const mutationKey = ['editPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof editPost>>,
    { id: string; data: EditPostRequest }
  > = (props) => {
    const { id, data } = props ?? {};

    return editPost(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EditPostMutationResult = NonNullable<Awaited<ReturnType<typeof editPost>>>;
export type EditPostMutationBody = EditPostRequest;
export type EditPostMutationError = unknown;

export const useEditPost = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof editPost>>,
      TError,
      { id: string; data: EditPostRequest },
      TContext
    >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof editPost>>,
  TError,
  { id: string; data: EditPostRequest },
  TContext
> => {
  const mutationOptions = getEditPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const archivePost = (id: string, options?: SecondParameter<typeof customAxiosMutator>) => {
  return customAxiosMutator<void>({ url: `/api/v1/posts/${id}`, method: 'PATCH' }, options);
};

export const getArchivePostMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof archivePost>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customAxiosMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof archivePost>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['archivePost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof archivePost>>, { id: string }> = (
    props
  ) => {
    const { id } = props ?? {};

    return archivePost(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ArchivePostMutationResult = NonNullable<Awaited<ReturnType<typeof archivePost>>>;

export type ArchivePostMutationError = unknown;

export const useArchivePost = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof archivePost>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof archivePost>>, TError, { id: string }, TContext> => {
  const mutationOptions = getArchivePostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createPost = (
  createPostRequest: CreatePostRequest,
  options?: SecondParameter<typeof customAxiosMutator>,
  signal?: AbortSignal
) => {
  return customAxiosMutator<void>(
    {
      url: `/api/v1/posts`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createPostRequest,
      signal,
    },
    options
  );
};

export const getCreatePostMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPost>>,
    TError,
    { data: CreatePostRequest },
    TContext
  >;
  request?: SecondParameter<typeof customAxiosMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPost>>,
  TError,
  { data: CreatePostRequest },
  TContext
> => {
  const mutationKey = ['createPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPost>>,
    { data: CreatePostRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePostMutationResult = NonNullable<Awaited<ReturnType<typeof createPost>>>;
export type CreatePostMutationBody = CreatePostRequest;
export type CreatePostMutationError = unknown;

export const useCreatePost = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPost>>,
      TError,
      { data: CreatePostRequest },
      TContext
    >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createPost>>,
  TError,
  { data: CreatePostRequest },
  TContext
> => {
  const mutationOptions = getCreatePostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createPostComment = (
  postId: string,
  createPostCommentRequest: CreatePostCommentRequest,
  options?: SecondParameter<typeof customAxiosMutator>,
  signal?: AbortSignal
) => {
  return customAxiosMutator<void>(
    {
      url: `/api/v1/posts/${postId}/comments`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createPostCommentRequest,
      signal,
    },
    options
  );
};

export const getCreatePostCommentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPostComment>>,
    TError,
    { postId: string; data: CreatePostCommentRequest },
    TContext
  >;
  request?: SecondParameter<typeof customAxiosMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPostComment>>,
  TError,
  { postId: string; data: CreatePostCommentRequest },
  TContext
> => {
  const mutationKey = ['createPostComment'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPostComment>>,
    { postId: string; data: CreatePostCommentRequest }
  > = (props) => {
    const { postId, data } = props ?? {};

    return createPostComment(postId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePostCommentMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPostComment>>
>;
export type CreatePostCommentMutationBody = CreatePostCommentRequest;
export type CreatePostCommentMutationError = unknown;

export const useCreatePostComment = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPostComment>>,
      TError,
      { postId: string; data: CreatePostCommentRequest },
      TContext
    >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createPostComment>>,
  TError,
  { postId: string; data: CreatePostCommentRequest },
  TContext
> => {
  const mutationOptions = getCreatePostCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const updatePostComment = (
  postId: string,
  commentId: string,
  editPostCommentRequest: EditPostCommentRequest,
  options?: SecondParameter<typeof customAxiosMutator>
) => {
  return customAxiosMutator<void>(
    {
      url: `/api/v1/posts/${postId}/comments/${commentId}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: editPostCommentRequest,
    },
    options
  );
};

export const getUpdatePostCommentMutationOptions = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePostComment>>,
    TError,
    { postId: string; commentId: string; data: EditPostCommentRequest },
    TContext
  >;
  request?: SecondParameter<typeof customAxiosMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePostComment>>,
  TError,
  { postId: string; commentId: string; data: EditPostCommentRequest },
  TContext
> => {
  const mutationKey = ['updatePostComment'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePostComment>>,
    { postId: string; commentId: string; data: EditPostCommentRequest }
  > = (props) => {
    const { postId, commentId, data } = props ?? {};

    return updatePostComment(postId, commentId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePostCommentMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePostComment>>
>;
export type UpdatePostCommentMutationBody = EditPostCommentRequest;
export type UpdatePostCommentMutationError = void;

export const useUpdatePostComment = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePostComment>>,
      TError,
      { postId: string; commentId: string; data: EditPostCommentRequest },
      TContext
    >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updatePostComment>>,
  TError,
  { postId: string; commentId: string; data: EditPostCommentRequest },
  TContext
> => {
  const mutationOptions = getUpdatePostCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const deletePostComment = (
  postId: string,
  commentId: string,
  options?: SecondParameter<typeof customAxiosMutator>
) => {
  return customAxiosMutator<void>(
    { url: `/api/v1/posts/${postId}/comments/${commentId}`, method: 'DELETE' },
    options
  );
};

export const getDeletePostCommentMutationOptions = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePostComment>>,
    TError,
    { postId: string; commentId: string },
    TContext
  >;
  request?: SecondParameter<typeof customAxiosMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deletePostComment>>,
  TError,
  { postId: string; commentId: string },
  TContext
> => {
  const mutationKey = ['deletePostComment'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deletePostComment>>,
    { postId: string; commentId: string }
  > = (props) => {
    const { postId, commentId } = props ?? {};

    return deletePostComment(postId, commentId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeletePostCommentMutationResult = NonNullable<
  Awaited<ReturnType<typeof deletePostComment>>
>;

export type DeletePostCommentMutationError = void;

export const useDeletePostComment = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deletePostComment>>,
      TError,
      { postId: string; commentId: string },
      TContext
    >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deletePostComment>>,
  TError,
  { postId: string; commentId: string },
  TContext
> => {
  const mutationOptions = getDeletePostCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const getPostsByGroup = (
  groupId: string,
  params?: GetPostsByGroupParams,
  options?: SecondParameter<typeof customAxiosMutator>,
  signal?: AbortSignal
) => {
  return customAxiosMutator<PostSlimDtoPagedResult>(
    { url: `/api/v1/groups/${groupId}/posts`, method: 'GET', params, signal },
    options
  );
};

export const getGetPostsByGroupQueryKey = (groupId: string, params?: GetPostsByGroupParams) => {
  return [`/api/v1/groups/${groupId}/posts`, ...(params ? [params] : [])] as const;
};

export const getGetPostsByGroupInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof getPostsByGroup>>,
    GetPostsByGroupParams['pageNumber']
  >,
  TError = void,
>(
  groupId: string,
  params?: GetPostsByGroupParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPostsByGroup>>,
        TError,
        TData,
        Awaited<ReturnType<typeof getPostsByGroup>>,
        QueryKey,
        GetPostsByGroupParams['pageNumber']
      >
    >;
    request?: SecondParameter<typeof customAxiosMutator>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPostsByGroupQueryKey(groupId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPostsByGroup>>,
    QueryKey,
    GetPostsByGroupParams['pageNumber']
  > = ({ signal, pageParam }) =>
    getPostsByGroup(
      groupId,
      { ...params, pageNumber: pageParam || params?.['pageNumber'] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!groupId,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPostsByGroup>>,
    TError,
    TData,
    Awaited<ReturnType<typeof getPostsByGroup>>,
    QueryKey,
    GetPostsByGroupParams['pageNumber']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPostsByGroupInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPostsByGroup>>
>;
export type GetPostsByGroupInfiniteQueryError = void;

export function useGetPostsByGroupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getPostsByGroup>>,
    GetPostsByGroupParams['pageNumber']
  >,
  TError = void,
>(
  groupId: string,
  params: undefined | GetPostsByGroupParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPostsByGroup>>,
        TError,
        TData,
        Awaited<ReturnType<typeof getPostsByGroup>>,
        QueryKey,
        GetPostsByGroupParams['pageNumber']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostsByGroup>>,
          TError,
          Awaited<ReturnType<typeof getPostsByGroup>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPostsByGroupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getPostsByGroup>>,
    GetPostsByGroupParams['pageNumber']
  >,
  TError = void,
>(
  groupId: string,
  params?: GetPostsByGroupParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPostsByGroup>>,
        TError,
        TData,
        Awaited<ReturnType<typeof getPostsByGroup>>,
        QueryKey,
        GetPostsByGroupParams['pageNumber']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostsByGroup>>,
          TError,
          Awaited<ReturnType<typeof getPostsByGroup>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPostsByGroupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getPostsByGroup>>,
    GetPostsByGroupParams['pageNumber']
  >,
  TError = void,
>(
  groupId: string,
  params?: GetPostsByGroupParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPostsByGroup>>,
        TError,
        TData,
        Awaited<ReturnType<typeof getPostsByGroup>>,
        QueryKey,
        GetPostsByGroupParams['pageNumber']
      >
    >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetPostsByGroupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getPostsByGroup>>,
    GetPostsByGroupParams['pageNumber']
  >,
  TError = void,
>(
  groupId: string,
  params?: GetPostsByGroupParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPostsByGroup>>,
        TError,
        TData,
        Awaited<ReturnType<typeof getPostsByGroup>>,
        QueryKey,
        GetPostsByGroupParams['pageNumber']
      >
    >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPostsByGroupInfiniteQueryOptions(groupId, params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPostsByGroupQueryOptions = <
  TData = Awaited<ReturnType<typeof getPostsByGroup>>,
  TError = void,
>(
  groupId: string,
  params?: GetPostsByGroupParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsByGroup>>, TError, TData>>;
    request?: SecondParameter<typeof customAxiosMutator>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPostsByGroupQueryKey(groupId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPostsByGroup>>> = ({ signal }) =>
    getPostsByGroup(groupId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!groupId,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getPostsByGroup>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetPostsByGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getPostsByGroup>>>;
export type GetPostsByGroupQueryError = void;

export function useGetPostsByGroup<
  TData = Awaited<ReturnType<typeof getPostsByGroup>>,
  TError = void,
>(
  groupId: string,
  params: undefined | GetPostsByGroupParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsByGroup>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostsByGroup>>,
          TError,
          Awaited<ReturnType<typeof getPostsByGroup>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPostsByGroup<
  TData = Awaited<ReturnType<typeof getPostsByGroup>>,
  TError = void,
>(
  groupId: string,
  params?: GetPostsByGroupParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsByGroup>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostsByGroup>>,
          TError,
          Awaited<ReturnType<typeof getPostsByGroup>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPostsByGroup<
  TData = Awaited<ReturnType<typeof getPostsByGroup>>,
  TError = void,
>(
  groupId: string,
  params?: GetPostsByGroupParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsByGroup>>, TError, TData>>;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetPostsByGroup<
  TData = Awaited<ReturnType<typeof getPostsByGroup>>,
  TError = void,
>(
  groupId: string,
  params?: GetPostsByGroupParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsByGroup>>, TError, TData>>;
    request?: SecondParameter<typeof customAxiosMutator>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPostsByGroupQueryOptions(groupId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
